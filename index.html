<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Element Blocks Puzzle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a237e, #0d47a1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial Black', Arial, sans-serif;
            touch-action: none;
        }
        #canvas {
            display: block;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // === 1. GRID 8Ã—8 ===
        const GRID_SIZE = 8;

        // === 3. Vibrant colors jaise image mein (dark nahi, bright & attractive) ===
        let COLORS = [
            '#FF6B35', // orange-red
            '#00D4FF', // cyan
            '#39FF14', // neon green
            '#D000FF', // magenta
            '#4169E1', // royal blue
            '#FFD700', // gold
            '#FF69B4', // hot pink
            '#FF1493', // deep pink
            '#00FF7F', // spring green
            '#FFA500'  // orange
        ];

        const SHAPES = [
            [[0,0]],
            [[0,0],[1,0]], [[0,0],[0,1]],
            [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]], [[0,0],[1,0],[0,1]], [[0,0],[1,0],[1,1]], [[0,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[1,1]],
            [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]], [[0,0],[1,0],[2,0],[3,0],[1,1]],
            [[0,0],[0,1],[1,0],[1,1]],
            [[0,0],[1,0],[1,1],[2,1]], [[0,0],[0,1],[1,1],[1,2]],
            [[0,0],[1,0],[2,0],[0,1]], [[0,0],[1,0],[2,0],[2,1]], [[0,0],[1,0],[2,0],[1,1]],
            [[0,0],[0,1],[0,2],[1,1]], [[0,0],[1,0],[1,1],[1,2]]
        ];

        let grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
        let pieces = [];
        let score = 0;
        let highScore = parseInt(localStorage.getItem('highScore')) || 0;
        let dragging = null;
        let offsetX = 0, offsetY = 0;
        let candidateRow = -1, candidateCol = -1;
        let gameOver = false;
        let settingsOpen = false;
        let soundOn = localStorage.getItem('soundOn') !== 'false';
        let bgmOn = localStorage.getItem('bgmOn') !== 'false';
        let skinOn = localStorage.getItem('skinOn') === 'true';
        let particles = [];
        let scorePopups = [];
        let comboPopups = [];

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let bgmOscillator = null;
        let bgmGainNode = null;
        const NOTES = {
            C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, A4: 440.00, B4: 493.88,
            C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99, A5: 880.00, B5: 987.77, C6: 1046.50
        };

        const speechSynth = window.speechSynthesis;

        function speak(text) {
            if (!soundOn) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.volume = 1.0;
            utterance.rate = 0.8;      // slow & clear
            utterance.pitch = 1.1;
            speechSynth.speak(utterance);
        }

        function playSound(freq, duration = 0.1, type = 'sine', volume = 0.2) {
            if (!soundOn) return;
            try {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(freq, now);
                osc.type = type;
                gain.gain.setValueAtTime(volume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                osc.start(now);
                osc.stop(now + duration);
            } catch (e) {}
        }

        function playClearSound(count) {
            playSound(NOTES.C6 + count * 70, 0.4 + count * 0.15, 'triangle', 0.5);
        }

        // === Resize â€“ Grid niche + score overwrite fix ===
        let cellSize, gridLeft, gridTop, bottomTop;
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            cellSize = Math.floor(Math.min(
                canvas.width / (GRID_SIZE + 3),
                canvas.height * 0.58 / GRID_SIZE   // grid ko niche shift karne ke liye height adjust
            ));

            gridLeft = (canvas.width - GRID_SIZE * cellSize) / 2;
            gridTop = cellSize * 2.8;               // GRID KO NICHE KIYA â€“ upar space badha
            bottomTop = gridTop + GRID_SIZE * cellSize + cellSize * 1.1; // niche gap kam
        }
        window.addEventListener('resize', resize);
        resize();

        function generatePiece() {
            const shapeIdx = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[shapeIdx].map(([x, y]) => [x, y]);
            const colorIdx = Math.floor(Math.random() * COLORS.length);
            const color = COLORS[colorIdx];
            const w = Math.max(...shape.map(p => p[0])) + 1;
            const h = Math.max(...shape.map(p => p[1])) + 1;
            return { shape, color, w, h };
        }

        function initPieces() {
            pieces = [generatePiece(), generatePiece(), generatePiece()];
        }

        function applySkin() {
            if (skinOn) {
                COLORS = ['#ff4500', '#1e90ff', '#228b22', '#8a2be2', '#0000cd', '#f4a460', '#ff1493', '#00fa9a', '#b8860b', '#dc143c'];
            } else {
                COLORS = ['#FF6B35', '#00D4FF', '#39FF14', '#D000FF', '#4169E1', '#FFD700', '#FF69B4', '#FF1493', '#00FF7F', '#FFA500'];
            }
        }

        // === Tiles look â€“ image jaise vibrant + rounded + shine ===
        function lighten(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            let R = (num >> 16) + amt;
            let G = (num >> 8 & 0x00FF) + amt;
            let B = (num & 0x0000FF) + amt;
            R = Math.min(255, Math.max(0, R));
            G = Math.min(255, Math.max(0, G));
            B = Math.min(255, Math.max(0, B));
            return `rgb(${R},${G},${B})`;
        }

        function darken(color, percent) {
            return lighten(color, -percent);
        }

        function drawBlock(x, y, color, size = cellSize, alpha = 1, isDragging = false) {
            ctx.save();
            ctx.globalAlpha = alpha;

            if (isDragging) {
                ctx.shadowColor = 'rgba(255,255,255,0.8)';
                ctx.shadowBlur = 25;
            }

            const radius = size * 0.20; // zyada rounded corners jaise real tiles
            roundRect(x + 3, y + 3, size - 6, size - 6, radius);

            const grad = ctx.createLinearGradient(x, y, x + size, y + size);
            grad.addColorStop(0, lighten(color, 50));
            grad.addColorStop(0.5, color);
            grad.addColorStop(1, darken(color, 35));
            ctx.fillStyle = grad;
            ctx.fill();

            // Shine highlight
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath();
            ctx.arc(x + size*0.28, y + size*0.28, size*0.22, 0, Math.PI*2);
            ctx.fill();

            // Border glow
            ctx.strokeStyle = lighten(color, 80);
            ctx.lineWidth = 5;
            ctx.stroke();

            ctx.restore();
        }

        function drawPiece(piece, px, py, scale = 1, alpha = 1, isDragging = false) {
            for (const [dx, dy] of piece.shape) {
                drawBlock(px + dx * cellSize * scale, py + dy * cellSize * scale, piece.color, cellSize * scale, alpha, isDragging);
            }
        }

        function drawGrid() {
            ctx.fillStyle = '#0f1c38';
            roundRect(gridLeft - 12, gridTop - 12, GRID_SIZE * cellSize + 24, GRID_SIZE * cellSize + 24, 35);
            ctx.fill();

            ctx.strokeStyle = 'rgba(100, 180, 255, 0.25)';
            ctx.lineWidth = 2;
            for (let i = 1; i < GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(gridLeft + i * cellSize, gridTop);
                ctx.lineTo(gridLeft + i * cellSize, gridTop + GRID_SIZE * cellSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gridLeft, gridTop + i * cellSize);
                ctx.lineTo(gridLeft + GRID_SIZE * cellSize, gridTop + i * cellSize);
                ctx.stroke();
            }
        }

        function drawPlaced() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c]) {
                        drawBlock(gridLeft + c * cellSize, gridTop + r * cellSize, grid[r][c]);
                    }
                }
            }
        }

        function drawPieces() {
            const slotWidth = canvas.width / 3;
            const slotHeight = Math.max(110, canvas.height - bottomTop);
            for (let i = 0; i < pieces.length; i++) {
                const p = pieces[i];
                const scaleX = (slotWidth * 0.95) / (p.w * cellSize);
                const scaleY = (slotHeight * 0.92) / (p.h * cellSize);
                p.scale = Math.min(scaleX, scaleY, 1.2);
                p.homeX = i * slotWidth + (slotWidth - p.w * cellSize * p.scale) / 2;
                p.homeY = bottomTop + (slotHeight - p.h * cellSize * p.scale) / 2;
                drawPiece(p, p.homeX, p.homeY, p.scale);
            }
        }

        function drawUI() {
            ctx.fillStyle = '#ffcc00';
            ctx.font = `${cellSize * 0.75}px Arial`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(`ðŸ‘‘ ${highScore}`, cellSize * 0.6, cellSize * 0.9);

            ctx.fillStyle = '#ffffff';
            ctx.font = `${cellSize * 1.25}px Arial Black`; // score thoda chhota
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${score}`, canvas.width / 2, cellSize * 1.05);

            ctx.fillStyle = '#a0a0a0';
            ctx.font = `${cellSize * 0.9}px Arial`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText('âš™ï¸', canvas.width - cellSize * 0.6, cellSize * 0.9);
        }

        // Settings panel â€“ vertical jaise image mein
        function drawSettings() {
            if (!settingsOpen) return;
            const panelW = Math.min(380, canvas.width * 0.85);
            const panelH = Math.min(520, canvas.height * 0.72);
            const panelX = (canvas.width - panelW) / 2;
            const panelY = (canvas.height - panelH) / 2;

            roundRect(panelX, panelY, panelW, panelH, 30);
            const grad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelH);
            grad.addColorStop(0, '#1e3a8a');
            grad.addColorStop(1, '#0f2557');
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 5;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = `${cellSize * 1.0}px Arial Black`;
            ctx.textAlign = 'center';
            ctx.fillText('Settings', panelX + panelW / 2, panelY + cellSize * 1.2);

            ctx.font = `${cellSize * 0.7}px Arial`;
            ctx.textAlign = 'right';
            ctx.fillText('Ã—', panelX + panelW - cellSize * 0.5, panelY + cellSize * 1.0);

            const toggleY = panelY + cellSize * 2.2;
            const spacing = cellSize * 1.3;
            ctx.font = `${cellSize * 0.65}px Arial`;
            ctx.textAlign = 'left';

            ctx.fillText('Sound', panelX + cellSize * 1.0, toggleY + cellSize * 0.4);
            drawToggle(panelX + panelW - cellSize * 2.0, toggleY + cellSize * 0.15, cellSize * 0.8, soundOn);

            ctx.fillText('BGM', panelX + cellSize * 1.0, toggleY + spacing + cellSize * 0.4);
            drawToggle(panelX + panelW - cellSize * 2.0, toggleY + spacing + cellSize * 0.15, cellSize * 0.8, bgmOn);

            ctx.fillText('Skin', panelX + cellSize * 1.0, toggleY + spacing * 2 + cellSize * 0.4);
            drawToggle(panelX + panelW - cellSize * 2.0, toggleY + spacing * 2 + cellSize * 0.15, cellSize * 0.8, skinOn);

            const btnY = toggleY + spacing * 3.5;
            const btnH = cellSize * 1.0;
            drawButton(panelX + cellSize * 1.0, btnY, panelW - cellSize * 2.0, btnH, 'ðŸŽ® More Games', '#22c55e');
            drawButton(panelX + cellSize * 1.0, btnY + btnH + 14, panelW - cellSize * 2.0, btnH, 'âš™ï¸ More Settings', '#eab308');
            drawButton(panelX + cellSize * 1.0, btnY + (btnH + 14) * 2, panelW - cellSize * 2.0, btnH, 'ðŸ  Home', '#3b82f6');
            drawButton(panelX + cellSize * 1.0, btnY + (btnH + 14) * 3, panelW - cellSize * 2.0, btnH, 'ðŸ”„ Replay', '#f97316');
        }

        function drawToggle(x, y, size, on) {
            roundRect(x, y, size * 1.9, size, size / 2);
            ctx.fillStyle = on ? '#22c55e' : '#6b7280';
            ctx.fill();
            const knobR = size * 0.48;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(on ? x + size * 1.42 : x + size * 0.48, y + size / 2, knobR, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGameOver() {
            if (!gameOver) return;
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffd700';
            ctx.font = `${cellSize * 1.3}px Arial Black`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(score > highScore ? 'Best Score!' : 'Game Over', canvas.width / 2, canvas.height / 2 - cellSize);
            ctx.fillStyle = '#ffffff';
            ctx.font = `${cellSize * 2.0}px Arial`;
            ctx.fillText(`${score}`, canvas.width / 2, canvas.height / 2 + cellSize * 0.4);
            drawButton(canvas.width / 2 - cellSize * 2.2, canvas.height / 2 + cellSize * 2.2, cellSize * 4.4, cellSize * 1.2, 'â–¶ Play Again', '#ef4444');
        }

        function addScorePopup(amount, x, y, color = '#ffea00') {
            scorePopups.push({ amount, x, y, life: 1.4, color });
        }

        function addComboPopup(text, x, y) {
            comboPopups.push({ text, x, y, life: 1.6 });
        }

        function emitParticles(centerX, centerY, color, num = 32) {
            for (let i = 0; i < num; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 7 + Math.random() * 9;
                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color,
                    life: 1.0,
                    size: 7 + Math.random() * 11
                });
            }
        }

        function canPlace(piece, row, col) {
            if (row < 0 || col < 0 || row + piece.h > GRID_SIZE || col + piece.w > GRID_SIZE) return false;
            for (const [dx, dy] of piece.shape) {
                if (grid[row + dy][col + dx] !== null) return false;
            }
            return true;
        }

        function placePiece(piece, row, col) {
            for (const [dx, dy] of piece.shape) {
                grid[row + dy][col + dx] = piece.color;
            }
        }

        function clearLines() {
            const fullRows = [], fullCols = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r].every(cell => cell !== null)) fullRows.push(r);
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                if (Array.from({length: GRID_SIZE}, (_, r) => grid[r][c]).every(cell => cell !== null)) fullCols.push(c);
            }
            const clearedCount = fullRows.length + fullCols.length;
            if (clearedCount === 0) return 0;

            fullRows.forEach(r => {
                for (let c = 0; c < GRID_SIZE; c++) emitParticles(gridLeft + c * cellSize + cellSize / 2, gridTop + r * cellSize + cellSize / 2, grid[r][c]);
            });
            fullCols.forEach(c => {
                for (let r = 0; r < GRID_SIZE; r++) if (!fullRows.includes(r)) emitParticles(gridLeft + c * cellSize + cellSize / 2, gridTop + r * cellSize + cellSize / 2, grid[r][c]);
            });

            playClearSound(clearedCount);

            let comboText = '';
            if (clearedCount === 2) comboText = 'Good!';
            else if (clearedCount === 3) comboText = 'Better!';
            else if (clearedCount >= 4) comboText = 'Best!';

            if (comboText) {
                addComboPopup(comboText, canvas.width / 2, gridTop + GRID_SIZE * cellSize / 2);
                speak(comboText);
            }

            fullRows.forEach(r => grid[r].fill(null));
            fullCols.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = null; });

            return clearedCount;
        }

        function canPlaceAny() {
            for (const p of pieces) {
                for (let r = 0; r <= GRID_SIZE - p.h; r++) {
                    for (let c = 0; c <= GRID_SIZE - p.w; c++) {
                        if (canPlace(p, r, c)) return true;
                    }
                }
            }
            return false;
        }

        function restart() {
            grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
            pieces = [];
            score = 0;
            particles = [];
            scorePopups = [];
            comboPopups = [];
            gameOver = false;
            settingsOpen = false;
            initPieces();
            stopBGM();
            playStartTune();
            if (bgmOn) playBGM();
            applySkin();
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
        }

        function handlePointerDown(e) {
            e.preventDefault();
            const pos = getPos(e);
            if (gameOver) {
                if (pos.x > canvas.width / 2 - cellSize * 2.2 && pos.x < canvas.width / 2 + cellSize * 2.2 &&
                    pos.y > canvas.height / 2 + cellSize * 2 && pos.y < canvas.height / 2 + cellSize * 3.4) {
                    restart();
                }
                return;
            }
            if (settingsOpen) {
                const panelW = Math.min(380, canvas.width * 0.85);
                const panelX = (canvas.width - panelW) / 2;
                const panelY = (canvas.height - Math.min(520, canvas.height * 0.72)) / 2;
                if (pos.x > panelX + panelW - cellSize * 1.2 && pos.y < panelY + cellSize * 1.4) {
                    settingsOpen = false;
                }
                const toggleY = panelY + cellSize * 2.2;
                const spacing = cellSize * 1.3;
                const toggleSize = cellSize * 0.8;
                if (pos.x > panelX + panelW - cellSize * 2.4 && pos.x < panelX + panelW - cellSize * 0.6) {
                    if (pos.y > toggleY && pos.y < toggleY + toggleSize) {
                        soundOn = !soundOn;
                        localStorage.setItem('soundOn', soundOn);
                    } else if (pos.y > toggleY + spacing && pos.y < toggleY + spacing + toggleSize) {
                        bgmOn = !bgmOn;
                        localStorage.setItem('bgmOn', bgmOn);
                        if (bgmOn) playBGM(); else stopBGM();
                    } else if (pos.y > toggleY + spacing * 2 && pos.y < toggleY + spacing * 2 + toggleSize) {
                        skinOn = !skinOn;
                        localStorage.setItem('skinOn', skinOn);
                        applySkin();
                        pieces.forEach(p => p.color = COLORS[Math.floor(Math.random() * COLORS.length)]);
                    }
                }
                const btnY = toggleY + spacing * 3.5;
                const btnH = cellSize * 1.0;
                if (pos.y > btnY && pos.y < btnY + btnH) alert('More Games');
                else if (pos.y > btnY + btnH + 14 && pos.y < btnY + (btnH + 14) * 2) alert('More Settings');
                else if (pos.y > btnY + (btnH + 14) * 2 && pos.y < btnY + (btnH + 14) * 3) window.location.href = '/';
                else if (pos.y > btnY + (btnH + 14) * 3 && pos.y < btnY + (btnH + 14) * 4) {
                    restart();
                    settingsOpen = false;
                }
                return;
            }
            if (pos.x > canvas.width - cellSize * 1.8 && pos.y < cellSize * 1.8) {
                settingsOpen = true;
                return;
            }
            for (let i = pieces.length - 1; i >= 0; i--) {
                const p = pieces[i];
                const minX = p.homeX;
                const maxX = minX + p.w * cellSize * p.scale;
                const minY = p.homeY;
                const maxY = minY + p.h * cellSize * p.scale;
                if (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY) {
                    dragging = p;
                    offsetX = pos.x - minX;
                    offsetY = pos.y - minY;
                    pieces.splice(i, 1);
                    playPickSound();
                    break;
                }
            }
        }

        function handlePointerMove(e) {
            if (!dragging) return;
            const pos = getPos(e);
            candidateCol = Math.floor((pos.x - offsetX - gridLeft) / cellSize);
            candidateRow = Math.floor((pos.y - offsetY - gridTop) / cellSize);
        }

        function handlePointerUp(e) {
            if (!dragging) return;
            let valid = canPlace(dragging, candidateRow, candidateCol);
            if (valid) {
                placePiece(dragging, candidateRow, candidateCol);
                playPlaceSound();
                const cleared = clearLines();
                const pieceScore = dragging.shape.length * 20;
                let clearScore = cleared * 100 * cleared;
                let bonus = 0;
                if (cleared >= 2) {
                    bonus = (cleared - 1) * 150 * cleared;
                    addScorePopup(bonus, gridLeft + GRID_SIZE * cellSize / 2, gridTop + GRID_SIZE * cellSize / 2 + cellSize * 0.5, '#00ff88');
                }
                const totalAdded = pieceScore + clearScore + bonus;
                score += totalAdded;
                addScorePopup(totalAdded, gridLeft + GRID_SIZE * cellSize / 2, gridTop + GRID_SIZE * cellSize / 2);
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                }
                pieces.push(generatePiece());
                if (!canPlaceAny()) {
                    gameOver = true;
                    playGameOverTune();
                }
            } else {
                pieces.push(dragging);
                playInvalidSound();
            }
            dragging = null;
            candidateRow = -1;
            candidateCol = -1;
        }

        canvas.addEventListener('pointerdown', handlePointerDown);
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('pointercancel', handlePointerUp);

        let lastTime = 0;
        function animate(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            particles = particles.filter(p => {
                p.x += p.vx * 60 * dt;
                p.y += p.vy * 60 * dt;
                p.vy += 40 * dt;
                p.life -= 2.3 * dt;
                if (p.life > 0) {
                    ctx.globalAlpha = p.life * 0.92;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });

            scorePopups = scorePopups.filter(sp => {
                sp.y -= 80 * dt;
                sp.life -= 1.2 * dt;
                if (sp.life > 0) {
                    ctx.globalAlpha = sp.life;
                    ctx.fillStyle = sp.color || '#ffea00';
                    ctx.font = `${cellSize * (sp.color === '#00ff88' ? 1.0 : 0.7)}px Arial Black`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`+${sp.amount}`, sp.x, sp.y);
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });

            comboPopups = comboPopups.filter(cp => {
                cp.y -= 50 * dt;
                cp.life -= 0.9 * dt;
                if (cp.life > 0) {
                    ctx.globalAlpha = cp.life;
                    ctx.fillStyle = '#ff5722';
                    ctx.font = `${cellSize * 1.2}px Arial Black`;
                    ctx.textAlign = 'center';
                    ctx.fillText(cp.text, cp.x, cp.y);
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });

            drawGrid();
            drawPlaced();
            drawPieces();
            if (dragging) {
                const valid = canPlace(dragging, candidateRow, candidateCol);
                drawPiece(dragging, gridLeft + candidateCol * cellSize, gridTop + candidateRow * cellSize, 1, valid ? 1 : 0.6, true);
            }
            drawUI();
            drawSettings();
            drawGameOver();

            // Footer ad
            ctx.fillStyle = 'rgba(0,0,50,0.8)';
            ctx.fillRect(0, canvas.height - 90, canvas.width, 90);
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Sponsored â€¢ CoinDCX â€“ Bigger Market', canvas.width / 2, canvas.height - 50);

            requestAnimationFrame(animate);
        }

        applySkin();
        initPieces();
        playStartTune();
        if (bgmOn) playBGM();
        requestAnimationFrame(animate);
    </script>
</body>
</html>
