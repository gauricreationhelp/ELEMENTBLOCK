<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Element Blocks Puzzle - Pro</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #20337a; /* Matches the dark blue background in image */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            height: 100vh;
        }
        #canvas {
            display: block;
            touch-action: none;
        }
        /* Footer Ad Placeholder as requested */
        .ad-footer {
            width: 100%;
            height: 60px;
            background: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #000;
            font-size: 12px;
            font-weight: bold;
            border-top: 2px solid #ccc;
        }
        .ad-content {
            width: 100%;
            max-width: 400px;
            height: 50px;
            background: #eee;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ad-footer">
        <div class="ad-content">
            <span>CoinDCX - Same Greeks. Bigger Market.</span>
            <span style="background: #ff5722; color: white; padding: 4px 8px; border-radius: 4px;">Download Now</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const GRID_SIZE = 8; // Changed to 8x8 per your request
        const COLORS = {
            blue: '#2196f3',
            red: '#f44336',
            yellow: '#ffeb3b',
            empty: '#0f1b44'
        };

        const SHAPES = [
            { shape: [[0,0]], color: COLORS.yellow },
            { shape: [[0,0],[1,0],[0,1],[1,1]], color: COLORS.blue },
            { shape: [[0,0],[1,0],[2,0]], color: COLORS.red },
            { shape: [[0,0],[0,1],[0,2]], color: COLORS.blue },
            { shape: [[0,0],[1,0],[2,0],[1,1]], color: COLORS.red },
            { shape: [[0,0],[1,0],[2,0],[0,1]], color: COLORS.yellow },
            { shape: [[0,0],[0,1],[1,1]], color: COLORS.blue },
            { shape: [[0,0],[1,0],[2,0],[3,0]], color: COLORS.red },
            { shape: [[0,0],[0,1],[0,2],[0,3]], color: COLORS.blue }
        ];

        // Game State
        let grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
        let pieces = [];
        let score = 0;
        let highScore = parseInt(localStorage.getItem('highScore')) || 0;
        let dragging = null;
        let offsetX = 0, offsetY = 0;
        let candidateRow = -1, candidateCol = -1;
        let gameOver = false;
        let settingsOpen = false;
        let soundOn = true;
        let bgmOn = false;

        let cellSize, gridLeft, gridTop, bottomTop;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 60; // Leave space for ad

            cellSize = Math.floor(Math.min(canvas.width * 0.9 / GRID_SIZE, canvas.height * 0.5 / GRID_SIZE));
            gridLeft = (canvas.width - GRID_SIZE * cellSize) / 2;
            // Shifted grid down as requested
            gridTop = canvas.height * 0.25; 
            bottomTop = gridTop + GRID_SIZE * cellSize + 40;
        }

        window.addEventListener('resize', resize);
        resize();

        function generatePiece() {
            const proto = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const w = Math.max(...proto.shape.map(p => p[0])) + 1;
            const h = Math.max(...proto.shape.map(p => p[1])) + 1;
            return { ...proto, w, h };
        }

        function initPieces() {
            pieces = [generatePiece(), generatePiece(), generatePiece()];
        }

        // Draw Block - Glossy look like image
        function drawBlock(x, y, color, size, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Main body
            ctx.fillStyle = color;
            ctx.fillRect(x + 1, y + 1, size - 2, size - 2);

            // Inner gloss/border effect
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 3, y + 3, size - 6, size - 6);

            // Darker bottom edge
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(x + 1, y + size - 4, size - 2, 3);
            
            ctx.restore();
        }

        function drawGrid() {
            // Grid Background
            ctx.fillStyle = COLORS.empty;
            ctx.fillRect(gridLeft - 4, gridTop - 4, GRID_SIZE * cellSize + 8, GRID_SIZE * cellSize + 8);

            // Grid Lines
            ctx.strokeStyle = '#1a2a5e';
            ctx.lineWidth = 1;
            for(let i=0; i<=GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(gridLeft + i * cellSize, gridTop);
                ctx.lineTo(gridLeft + i * cellSize, gridTop + GRID_SIZE * cellSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gridLeft, gridTop + i * cellSize);
                ctx.lineTo(gridLeft + GRID_SIZE * cellSize, gridTop + i * cellSize);
                ctx.stroke();
            }

            // Placed Blocks
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c]) {
                        drawBlock(gridLeft + c * cellSize, gridTop + r * cellSize, grid[r][c], cellSize);
                    }
                }
            }
        }

        function drawUI() {
            // Header: Crown and High Score
            ctx.fillStyle = '#fbc02d';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`üëë ${highScore}`, 20, 40);

            // Main Score
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(score, canvas.width / 2, 80);

            // Settings Gear
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('‚öôÔ∏è', canvas.width - 20, 45);
        }

        function drawPieces() {
            const slotW = canvas.width / 3;
            pieces.forEach((p, i) => {
                const scale = 0.7;
                p.homeX = i * slotW + (slotW - p.w * cellSize * scale) / 2;
                p.homeY = bottomTop;
                
                p.shape.forEach(([dx, dy]) => {
                    drawBlock(p.homeX + dx * cellSize * scale, p.homeY + dy * cellSize * scale, p.color, cellSize * scale);
                });
            });
        }

        function drawSettings() {
            if (!settingsOpen) return;

            // Overlay
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Vertical Panel (Matches Image 1)
            const w = 300;
            const h = 450;
            const x = (canvas.width - w) / 2;
            const y = (canvas.height - h) / 2;

            // Box
            ctx.fillStyle = '#4a69bd';
            ctx.roundRect ? ctx.roundRect(x, y, w, h, 15) : ctx.fillRect(x, y, w, h);
            ctx.fill();

            // Header
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Settings', x + w/2, y + 40);
            ctx.fillText('‚úï', x + w - 30, y + 40);

            // Top Buttons (Sound, BGM, Skin)
            const iconY = y + 80;
            drawSettingIcon(x + 60, iconY, 'üîä', 'Sound', soundOn);
            drawSettingIcon(x + 150, iconY, 'üéµ', 'BGM', bgmOn);
            drawSettingIcon(x + 240, iconY, 'üëï', 'Skin', true);

            // List Buttons (Green Buttons like image)
            const btnW = 240;
            const btnH = 50;
            const btnX = x + (w - btnW) / 2;
            
            drawListButton(btnX, y + 180, btnW, btnH, 'üéÆ More Games', '#44bd32');
            drawListButton(btnX, y + 245, btnW, btnH, '‚öôÔ∏è More Settings', '#44bd32');
            drawListButton(btnX, y + 310, btnW, btnH, 'üè† Home', '#44bd32');
            drawListButton(btnX, y + 375, btnW, btnH, 'üîÑ Replay', '#44bd32');
        }

        function drawSettingIcon(x, y, icon, label, active) {
            ctx.font = '30px Arial';
            ctx.fillText(icon, x, y);
            if (!active) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(x-15, y-15); ctx.lineTo(x+15, y+15); ctx.stroke();
            }
            ctx.font = '14px Arial';
            ctx.fillText(label, x, y + 30);
        }

        function drawListButton(x, y, w, h, text, color) {
            ctx.fillStyle = color;
            ctx.roundRect ? ctx.roundRect(x, y, w, h, 10) : ctx.fillRect(x, y, w, h);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, x + w/2, y + h/2 + 6);
        }

        // Logic
        function canPlace(piece, row, col) {
            if (row < 0 || col < 0 || row + piece.h > GRID_SIZE || col + piece.w > GRID_SIZE) return false;
            for (const [dx, dy] of piece.shape) {
                if (grid[row + dy][col + dx] !== null) return false;
            }
            return true;
        }

        function checkLines() {
            let linesCleared = 0;
            let rowsToClear = [];
            let colsToClear = [];

            // Rows
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r].every(c => c !== null)) rowsToClear.push(r);
            }
            // Cols
            for (let c = 0; c < GRID_SIZE; c++) {
                let full = true;
                for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === null) full = false;
                if (full) colsToClear.push(c);
            }

            rowsToClear.forEach(r => grid[r].fill(null));
            colsToClear.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = null; });

            linesCleared = rowsToClear.length + colsToClear.length;
            
            // SCORE ONLY INCREASES ON LINE CLEAR
            if (linesCleared > 0) {
                score += (linesCleared * 100); 
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('highScore', highScore);
                }
            }
        }

        function isGameOver() {
            for (const p of pieces) {
                for (let r = 0; r <= GRID_SIZE - p.h; r++) {
                    for (let c = 0; c <= GRID_SIZE - p.w; c++) {
                        if (canPlace(p, r, c)) return false;
                    }
                }
            }
            return true;
        }

        // Input Handling
        function getPos(e) {
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX, y: t.clientY };
        }

        canvas.addEventListener('pointerdown', e => {
            const pos = getPos(e);
            
            // Settings Toggle
            if (pos.x > canvas.width - 60 && pos.y < 60) {
                settingsOpen = !settingsOpen;
                return;
            }

            if (settingsOpen) {
                if (pos.y > (canvas.height/2 + 150)) settingsOpen = false; // Close on bottom click
                return;
            }

            // Piece selection
            const slotW = canvas.width / 3;
            pieces.forEach((p, i) => {
                const scale = 0.7;
                if (pos.x > p.homeX && pos.x < p.homeX + p.w*cellSize*scale && 
                    pos.y > p.homeY && pos.y < p.homeY + p.h*cellSize*scale) {
                    dragging = p;
                    dragging.index = i;
                    offsetX = pos.x - p.homeX;
                    offsetY = pos.y - p.homeY;
                }
            });
        });

        canvas.addEventListener('pointermove', e => {
            if (!dragging) return;
            const pos = getPos(e);
            dragging.curX = pos.x - offsetX;
            dragging.curY = pos.y - offsetY;

            candidateCol = Math.round((dragging.curX - gridLeft) / cellSize);
            candidateRow = Math.round((dragging.curY - gridTop) / cellSize);
        });

        canvas.addEventListener('pointerup', () => {
            if (!dragging) return;

            if (canPlace(dragging, candidateRow, candidateCol)) {
                dragging.shape.forEach(([dx, dy]) => {
                    grid[candidateRow + dy][candidateCol + dx] = dragging.color;
                });
                pieces.splice(dragging.index, 1);
                checkLines();
                if (pieces.length === 0) initPieces();
                if (isGameOver()) gameOver = true;
            }

            dragging = null;
            candidateRow = -1;
            candidateCol = -1;
        });

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawUI();
            drawPieces();

            if (dragging) {
                const isValid = canPlace(dragging, candidateRow, candidateCol);
                dragging.shape.forEach(([dx, dy]) => {
                    const drawX = dragging.curX + dx * cellSize;
                    const drawY = dragging.curY + dy * cellSize;
                    drawBlock(drawX, drawY, dragging.color, cellSize, isValid ? 1 : 0.5);
                });
            }

            if (gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.font = '20px Arial';
                ctx.fillText('Tap to Restart', canvas.width/2, canvas.height/2 + 50);
            }

            drawSettings();
            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', () => { if(gameOver) location.reload(); });

        initPieces();
        animate();

    </script>
</body>
</html>
