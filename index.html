<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Element Blocks Puzzle - 8x8 Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a237e, #0d47a1);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-family: 'Arial Black', Arial, sans-serif;
            touch-action: none;
            height: 100vh;
        }
        #canvas {
            display: block;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        /* Footer for Ads */
        .ad-footer {
            width: 100%;
            height: 60px;
            background: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #333;
            border-top: 2px solid #ccc;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="ad-footer">
        <div style="display: flex; align-items: center; gap: 10px; width: 90%; max-width: 400px;">
            <div style="background: #eee; padding: 5px; border-radius: 4px; flex-grow: 1;">CoinDCX - Same Greeks. Bigger Market.</div>
            <div style="background: #ff5722; color: white; padding: 8px 12px; border-radius: 4px; font-weight: bold; font-size: 12px;">INSTALL</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // --- Constants ---
        const GRID_SIZE = 8; // Changed to 8x8 as requested
        let COLORS = ['#ff7518', '#00bfff', '#32cd32', '#9932cc', '#4169e1', '#ffd700', '#ff69b4', '#ff1493', '#00ff7f', '#daa520'];
        const SHAPES = [
            [[0,0]],
            [[0,0],[1,0]], [[0,0],[0,1]],
            [[0,0],[1,0],[2,0]], [[0,0],[0,1],[0,2]], [[0,0],[1,0],[0,1]], [[0,0],[1,0],[1,1]], [[0,0],[0,1],[1,1]], [[0,0],[1,0],[2,0],[1,1]],
            [[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]], [[0,0],[1,0],[2,0],[3,0],[1,1]],
            [[0,0],[0,1],[1,0],[1,1]],
            [[0,0],[1,0],[1,1],[2,1]], [[0,0],[0,1],[1,1],[1,2]],
            [[0,0],[1,0],[2,0],[0,1]], [[0,0],[1,0],[2,0],[2,1]], [[0,0],[1,0],[2,0],[1,1]],
            [[0,0],[0,1],[0,2],[1,1]], [[0,0],[1,0],[1,1],[1,2]]
        ];

        // --- Game state ---
        let grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
        let pieces = [];
        let score = 0;
        let highScore = parseInt(localStorage.getItem('highScore')) || 0;
        let dragging = null;
        let offsetX = 0, offsetY = 0;
        let candidateRow = -1, candidateCol = -1;
        let gameOver = false;
        let settingsOpen = false;
        let soundOn = localStorage.getItem('soundOn') !== 'false';
        let bgmOn = localStorage.getItem('bgmOn') !== 'false';
        let skinOn = localStorage.getItem('skinOn') === 'true';
        let particles = [];
        let scorePopups = [];
        let comboPopups = [];

        // --- Audio Logic ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let bgmOscillator = null;
        let bgmGainNode = null;
        const NOTES = { C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, C5: 523.25, E5: 659.25, G5: 783.99, C6: 1046.50 };

        function playSound(freq, duration = 0.1, type = 'sine', volume = 0.2) {
            if (!soundOn) return;
            try {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(freq, now);
                osc.type = type;
                gain.gain.setValueAtTime(volume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                osc.start(now); osc.stop(now + duration);
            } catch (e) {}
        }

        function playClearSound(count) { playSound(NOTES.C6 + count * 50, 0.4, 'triangle', 0.4); }

        // --- Layout ---
        let cellSize, gridLeft, gridTop, bottomTop;
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 60; // Subtract ad height

            const maxPossibleCell = Math.min(
                canvas.width / (GRID_SIZE + 1),
                (canvas.height * 0.65) / GRID_SIZE
            );
            cellSize = Math.floor(maxPossibleCell);
            gridLeft = (canvas.width - GRID_SIZE * cellSize) / 2;
            // Shifted down slightly as requested
            gridTop = canvas.height * 0.25; 
            bottomTop = gridTop + GRID_SIZE * cellSize + cellSize;
        }
        window.addEventListener('resize', resize);
        resize();

        function generatePiece() {
            const shapeIdx = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[shapeIdx].map(([x, y]) => [x, y]);
            const colorIdx = Math.floor(Math.random() * COLORS.length);
            const color = COLORS[colorIdx];
            const w = Math.max(...shape.map(p => p[0])) + 1;
            const h = Math.max(...shape.map(p => p[1])) + 1;
            return { shape, color, w, h };
        }

        function initPieces() { pieces = [generatePiece(), generatePiece(), generatePiece()]; }

        function applySkin() {
            if (skinOn) {
                COLORS = ['#ff4500', '#1e90ff', '#228b22', '#8a2be2', '#0000cd', '#f4a460', '#ff1493', '#00fa9a', '#b8860b', '#dc143c'];
            } else {
                COLORS = ['#ff7518', '#00bfff', '#32cd32', '#9932cc', '#4169e1', '#ffd700', '#ff69b4', '#ff1493', '#00ff7f', '#daa520'];
            }
        }

        // --- Drawing ---
        function lighten(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            let R = (num >> 16) + amt;
            let G = (num >> 8 & 0x00FF) + amt;
            let B = (num & 0x0000FF) + amt;
            return `rgb(${R > 255 ? 255 : R < 0 ? 0 : R},${G > 255 ? 255 : G < 0 ? 0 : G},${B > 255 ? 255 : B < 0 ? 0 : B})`;
        }

        function darken(color, percent) { return lighten(color, -percent); }

        function drawBlock(x, y, color, size = cellSize, alpha = 1, isDragging = false) {
            ctx.save();
            ctx.globalAlpha = alpha;
            if (isDragging) { ctx.shadowColor = '#fff'; ctx.shadowBlur = 10; }
            const radius = size * 0.15;
            roundRect(x + 1, y + 1, size - 2, size - 2, radius);
            const grad = ctx.createLinearGradient(x, y, x, y + size);
            grad.addColorStop(0, lighten(color, 25));
            grad.addColorStop(1, darken(color, 25));
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = lighten(color, 45);
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
        }

        function drawGrid() {
            ctx.fillStyle = '#0d1b2a';
            roundRect(gridLeft - 5, gridTop - 5, GRID_SIZE * cellSize + 10, GRID_SIZE * cellSize + 10, 15);
            ctx.fill();
            ctx.strokeStyle = '#ffffff15';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(gridLeft + i * cellSize, gridTop);
                ctx.lineTo(gridLeft + i * cellSize, gridTop + GRID_SIZE * cellSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(gridLeft, gridTop + i * cellSize);
                ctx.lineTo(gridLeft + GRID_SIZE * cellSize, gridTop + i * cellSize);
                ctx.stroke();
            }
        }

        function drawPlaced() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c]) drawBlock(gridLeft + c * cellSize, gridTop + r * cellSize, grid[r][c]);
                }
            }
        }

        function drawPieces() {
            const slotW = canvas.width / 3;
            const slotH = canvas.height - bottomTop;
            pieces.forEach((p, i) => {
                const scaleX = (slotW * 0.8) / (p.w * cellSize);
                const scaleY = (slotH * 0.8) / (p.h * cellSize);
                p.scale = Math.min(scaleX, scaleY, 0.8);
                p.homeX = i * slotW + (slotW - p.w * cellSize * p.scale) / 2;
                p.homeY = bottomTop + (slotH - p.h * cellSize * p.scale) / 2;
                for (const [dx, dy] of p.shape) {
                    drawBlock(p.homeX + dx * cellSize * p.scale, p.homeY + dy * cellSize * p.scale, p.color, cellSize * p.scale);
                }
            });
        }

        function drawUI() {
            // Highscore
            ctx.fillStyle = '#ffcc00';
            ctx.font = `bold ${cellSize * 0.5}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText(`üëë ${highScore}`, 20, 40);

            // Current Score - Small as requested
            ctx.fillStyle = 'white';
            ctx.font = `bold ${cellSize * 1.1}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(`${score}`, canvas.width / 2, 80);

            // Gear Icon
            ctx.fillStyle = '#fff';
            ctx.font = `${cellSize * 0.7}px Arial`;
            ctx.textAlign = 'right';
            ctx.fillText('‚öôÔ∏è', canvas.width - 20, 40);
        }

        function roundRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.closePath();
        }

        // --- Settings Panel (Vertical as requested) ---
        function drawSettings() {
            if (!settingsOpen) return;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const panelW = 280;
            const panelH = 420;
            const panelX = (canvas.width - panelW) / 2;
            const panelY = (canvas.height - panelH) / 2;

            ctx.fillStyle = '#3d5a80';
            roundRect(panelX, panelY, panelW, panelH, 20);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Settings', canvas.width / 2, panelY + 40);
            ctx.font = '30px Arial';
            ctx.fillText('‚úï', panelX + panelW - 30, panelY + 40);

            const itemX = panelX + 40;
            const itemY = panelY + 100;
            
            // Draw Toggles
            drawToggleRow('Sound', itemY, soundOn);
            drawToggleRow('BGM', itemY + 60, bgmOn);
            drawToggleRow('Skin', itemY + 120, skinOn);

            // Vertical Buttons
            const btnW = 220;
            const btnH = 45;
            const btnX = panelX + (panelW - btnW) / 2;
            drawRectBtn(btnX, itemY + 180, btnW, btnH, 'üéÆ More Games', '#4caf50');
            drawRectBtn(btnX, itemY + 235, btnW, btnH, '‚öôÔ∏è More Settings', '#4caf50');
            drawRectBtn(btnX, itemY + 290, btnW, btnH, 'üîÑ Replay', '#e67e22');
        }

        function drawToggleRow(label, y, on) {
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(label, (canvas.width - 200) / 2, y + 15);
            
            const tx = (canvas.width + 80) / 2;
            const tw = 40;
            const th = 22;
            roundRect(tx, y, tw, th, th/2);
            ctx.fillStyle = on ? '#4caf50' : '#888';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(on ? tx + tw - 11 : tx + 11, y + 11, 8, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRectBtn(x, y, w, h, text, color) {
            roundRect(x, y, w, h, 10);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, x + w / 2, y + h / 2 + 6);
        }

        function drawGameOver() {
            if (!gameOver) return;
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 40);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 60px Arial';
            ctx.fillText(`${score}`, canvas.width / 2, canvas.height / 2 + 40);
            drawRectBtn(canvas.width / 2 - 75, canvas.height / 2 + 100, 150, 50, 'RESTART', '#ff8c00');
        }

        // --- Core Logic ---
        function canPlace(piece, row, col) {
            if (row < 0 || col < 0 || row + piece.h > GRID_SIZE || col + piece.w > GRID_SIZE) return false;
            for (const [dx, dy] of piece.shape) {
                if (grid[row + dy][col + dx] !== null) return false;
            }
            return true;
        }

        function clearLines() {
            let fullRows = [], fullCols = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r].every(c => c !== null)) fullRows.push(r);
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                let colFull = true;
                for (let r = 0; r < GRID_SIZE; r++) if (grid[r][c] === null) colFull = false;
                if (colFull) fullCols.push(c);
            }

            const totalCleared = fullRows.length + fullCols.length;
            if (totalCleared > 0) {
                // Effects
                fullRows.forEach(r => grid[r].forEach((color, c) => emitParticles(gridLeft + c * cellSize + cellSize/2, gridTop + r * cellSize + cellSize/2, color)));
                fullCols.forEach(c => { for(let r=0; r<GRID_SIZE; r++) emitParticles(gridLeft + c * cellSize + cellSize/2, gridTop + r * cellSize + cellSize/2, grid[r][c]); });
                
                playClearSound(totalCleared);
                
                // SCORE INCREASES ONLY ON LINE CLEAR
                score += totalCleared * 100 * totalCleared;
                if (score > highScore) { highScore = score; localStorage.setItem('highScore', highScore); }
                
                // Remove blocks
                fullRows.forEach(r => grid[r].fill(null));
                fullCols.forEach(c => { for (let r = 0; r < GRID_SIZE; r++) grid[r][c] = null; });
            }
            return totalCleared;
        }

        function emitParticles(x, y, color) {
            for(let i=0; i<6; i++) {
                particles.push({x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, color, life: 1, size: Math.random()*5+2});
            }
        }

        function handlePointerDown(e) {
            e.preventDefault();
            const pos = getPos(e);
            if (gameOver) {
                if (pos.x > canvas.width/2 - 75 && pos.x < canvas.width/2 + 75 && pos.y > canvas.height/2 + 100 && pos.y < canvas.height/2 + 150) location.reload();
                return;
            }
            if (settingsOpen) {
                if (pos.x > canvas.width - 80 && pos.y < 80) settingsOpen = false;
                return;
            }
            if (pos.x > canvas.width - 60 && pos.y < 60) { settingsOpen = true; return; }
            
            pieces.forEach((p, i) => {
                if (pos.x > p.homeX && pos.x < p.homeX + p.w * cellSize * p.scale && pos.y > p.homeY && pos.y < p.homeY + p.h * cellSize * p.scale) {
                    dragging = p; dragging.index = i;
                    offsetX = pos.x - p.homeX; offsetY = pos.y - p.homeY;
                    pieces.splice(i, 1);
                    playSound(NOTES.C5, 0.05, 'square', 0.2);
                }
            });
        }

        function handlePointerMove(e) {
            if (!dragging) return;
            const pos = getPos(e);
            candidateCol = Math.floor((pos.x - offsetX - gridLeft) / cellSize);
            candidateRow = Math.floor((pos.y - offsetY - gridTop) / cellSize);
        }

        function handlePointerUp() {
            if (!dragging) return;
            if (canPlace(dragging, candidateRow, candidateCol)) {
                dragging.shape.forEach(([dx, dy]) => grid[candidateRow + dy][candidateCol + dx] = dragging.color);
                playSound(NOTES.G4, 0.1, 'sine', 0.3);
                clearLines();
                pieces.push(generatePiece());
                if (!pieces.some(p => {
                    for(let r=0; r<=GRID_SIZE-p.h; r++) for(let c=0; c<=GRID_SIZE-p.w; c++) if(canPlace(p,r,c)) return true;
                    return false;
                })) gameOver = true;
            } else {
                pieces.splice(dragging.index, 0, dragging);
            }
            dragging = null;
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX - rect.left, y: t.clientY - rect.top };
        }

        canvas.addEventListener('pointerdown', handlePointerDown);
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);

        function animate(time) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles = particles.filter(p => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.02;
                if (p.life > 0) {
                    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                    return true;
                }
                return false;
            });
            ctx.globalAlpha = 1;
            drawGrid();
            drawPlaced();
            drawPieces();
            if (dragging) {
                const valid = canPlace(dragging, candidateRow, candidateCol);
                dragging.shape.forEach(([dx, dy]) => drawBlock(gridLeft + (candidateCol + dx) * cellSize, gridTop + (candidateRow + dy) * cellSize, dragging.color, cellSize, valid ? 1 : 0.5));
            }
            drawUI();
            drawSettings();
            drawGameOver();
            requestAnimationFrame(animate);
        }
        initPieces();
        animate();
    </script>
</body>
</html>
